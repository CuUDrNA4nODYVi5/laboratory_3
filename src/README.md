## Отчет по лабораторной работе №  3

#### № группы: ПМ - 2402

#### Выполнил: Коротеева Юлия Андреевна

#### Вариант: `14`

### Cодержание:
- [Постановка задачи](#1-постановка-задачи)
- [Алгоритм](#2-алгоритм)
- [Программа](#3-программа)
- [Анализ правильности решения](#4-анализ-правильности-решения)

### 1. Постановка задачи

Программа получает на вход 4 переменных titlePoem, author, currentlyVersion и previousVersion. В дальнейшем
нужно сравнить значения переменных currentlyVersion и previousVersion относительно друг друга.

Данную задачу можно разделить на 12 частей:
1)Сначала создаем новый класс гит;
2)Выводим стихотворение, переопределяем toString;
3)Добавляем строки в конец стихотворения;
4)Удаляем строки с указанным номером из стихотворения;
5)Вставляем новые строки в указанное место стихотворения;
6)Сохраняем две версии стихотворения: текущую и предыдущую(последнюю);
7)Выводим сохраненные версии;
8)Удаляем указанные версии;
9)Откатываем текущую версию до последних изменений;
10)Сравниваем текущую и предыдущую версии между собой;
11)Находим общие строки в текущей и предыдущей версиях;
12)Находим различные строки в текущей и предыдущей версиях;

Всего нужно выполнить 12 пунктов плана.


### 2. Алгоритм

1. **Ввод данных:**  
   Программа создает класс Git, с помощью конструктора считывает 4 строки, обозначенные как `titlePoem`,`author`,`currentlyVersion` и `previousVersion`.

2. **Вывод стихотворения:**  
   Отображение текущей версии стихотворения в формате: «НазваниеСтиха - ИмяПоэта» и строки построчно. Для этого мы переопределяем
   переменные `titlePoem` и `author` в toString в необходимом формате. 

3. **Добавление строки:**
   Для того, чтобы добавить строку в конец стихотворения необходимо создать метод addLine(), в котором к переменной `currentlyVersion`
   каждый раз добавляется новая строка.

4. **Удаление строки по номеру:**
   Для того, чтобы удалить строку в конце стихотворения необходимо создать метод deletedLine(), в котором создается массив []array, 
   разделяющий введенную строку из текущей версии на подстроки. Затем рассматриваем условия, когда существует хотя бы одна строка,
   которую мы можем удалить, и число строк не превышает длины массива. Создаем пустой объект `str`, в который в дальнейшем добавляем 
   посимвольно удаленную строку. Полученную строку добавляем в текущую версию.

5. **Вставка строки по номеру:**
   Для того, чтобы вставить строку в стихотворения необходимо создать метод insertedLine(), в котором создается массив []array,
   разделяющий введенную строку из текущей версии на подстроки. Затем рассматриваем условия, когда существует хотя бы одна строка,
   и число строк не превышает длины массива. Создаем пустой объект `str`, в который в дальнейшем добавляем посимвольно удаленную 
   строку. Обращаемся к циклу, если текущий индекс не является индексом последнего элемента, то добавляем текст в конец строки.
   Затем добавляем символы новой строки по индексу в массиве с именем объекта, за которым следует символ новой 
   строки. Принимаем содержимое объекта, преобразовывает в другой объект. Полученную строку добавляем в текущую версию.

6. **Сохранение версии:**
   Для того, чтобы сохранить новую версию стихотворения, необходимо создать метод saveVersion(). С помощью переменной `previousVersion`
   заменяем предыдущую версию на текущую.

7. **Просмотр сохранений:**
   Для того, чтобы посмотреть последние сохранения стихотворения, необходимо создать метод displayVersion(). Вводим переменную
   `versionNumber`, которая указывает на номер той или иной версии. Если номер версии соответсвует 0, то выводим 
   текущую версию `currentlyVersion`. Если номер версии соответсвует 1, то выводим предыдущую(последнюю версию) `previousVersion`.

8. **Удаление сохранения:**
   Для того, чтобы удалить указанное сохранение стихотворения, необходимо создать метод deleteSave(). Переменная `previousVersion` 
   очищает содержимое переменной, эффективно «удаляя» или сбрасывая текущее сохранение. 

9. **Откат к сохранению:**
   Для того, чтобы найти откат к сохранению стихотворения, необходимо создать метод rollbackVersion(). Перемещаем значение предыдущей
   версии `this.previousVersion` в переменную предыдущей версии `this.currentlyVersion`. Затем присваивает значение параметра 
   переменной экземпляра `version`(которую мы ввели заранее), которая будет новой предыдущей версией `previousVersion` . 
   Выводим новую текущую версию.  

10. **Сравнение версий:**
    Для того, чтобы сравнить версии стихотворения, необходимо создать метод versionToComparison(). Сравниваем каждый элемент 
    текущей строки с элементами предыдущей строки. Если текст в переменной текущей версии точно совпадает
    с текстом в переменной предыдущей версии, то выводим необходимый результат.

11. **Общие строки между версиями:**
    Для того, чтобы найти общие строки между версиями стихотворения, необходимо создать метод printCommonStrings().
    Создаем два массива, которые разбивают строки текущей версии на массив строк. Для сохранения изменения значений введем переменную `result`.
    Вводим массив, который используется в качестве «трекера». Каждый индекс в массиве соответствует строке в массиве. С помощью двух циклов
    сравниваем элементы. Проверяет, является ли логическое значение, хранящееся в индексе массива, истинным. Если условие было, то в этой строке будет выведено значение,
    хранящееся в переменной, в консоль. После вывода переменной эта строка устанавливает соответствующий элемент по индексу в массиве в значение

12. **Различные строки между версиями:**
    Для того, чтобы найти различные строки между версиями стихотворения, необходимо создать метод printVersionDiff().
    Создаем два массива, которые разбивают строки текущей версии на массив строк. Для сохранения изменения значений введем переменную `result`.
    Вводим массив, который используется в качестве «трекера». Каждый индекс в массиве соответствует строке в массиве. С помощью двух циклов
    сравниваем элементы. Указываем на то, что строка по индексу массива была найдена в массиве. Рассматриваем цикл для предыдущей версии.
    Проверяет, не найдена ли в массиве текущая строка, соответствующая индексу. Если строка from не найдена, то флаг, соответствующий этой строке, будет ложным.
    Если условие истинно, то эта строка выводит текущую строку из массива с префиксом "-", чтобы показать, что эта строка уникальна для старой версии. 
    Рассматриваем цикл для текущей версии. Строка получает текущую строку и сохраняет ее в переменной. Рассматриваем цикл для предыдущей версии
    и сравниваем элементы. Проверяет, не было ли найдено то, что вы искали, в предыдущих итерациях цикла. Если условие истинно, то эта строка выводит текущую 
    строку из массива с префиксом "+", чтобы показать, что эта строка уникальна для новой(текущей) версии.

```

### 3. Программа

```Java
import java.io.PrintStream;
import java.util.Scanner;

//задание 1 (Создание объекта гита)
class Git {//создаем класс гит
    private String titlePoem;//вводим переменную названия стихотворения
    private String author;// вводим переменную автора
    private String currentlyVersion;// вводим переменную текущей версии
    private String previousVersion;// вводим переменную предыдущей версии

    public Git(String titlePoem, String author) {//прописываем конструктор класса
        this.titlePoem = titlePoem;
        this.author = author;
        this.currentlyVersion = "";
        this.previousVersion = "";
    }

    //задание 2 (Вывод стихотворения)
    @Override
    public String toString() {
        return "«" + titlePoem + " - " + author + "»" + "\n" + currentlyVersion; //выводим строку формата «НазваниеСтиха- ИмяПоэта»
    }

    //задание 3 (Добавление строки)
    public void addLine(String line) {
        currentlyVersion += line + "\n";// добавляем строку к последней(текущей) версии и спускает курсив на следующую строку
    }

    //задание 4 (Удаление строки по номеру)
    public void deletedLine(int line_number) {
        String[] array = currentlyVersion.split("\n");//создаем массив, который разделяем на подстроки
        if (line_number >= 1 && line_number <= array.length) {//рассматривает условия, когда существует хотя бы одна строка
            // и число строк не превышает длины массива
            String str = "";//создаем пустую строку
            for (int i = 0; i < array.length; i++) {//обращаемся к циклу
                if (i != line_number - 1) {//если текущий индекс не является индексом последнего элемента, то
                    str += array[i] + "\n";// добавляем символы новой строки
                }
            }
            currentlyVersion = str;//принимает содержимое объекта, преобразовывает в другой объект, затем
            //сохраняет полученную строку в переменную текущей версии
        } else {
            System.out.println("Неверный номер строки!");//иначе выводим ошибку
        }
    }

    //задание 5 (Вставка строки по номеру)
    public void insertedLine(int line_number, String line) {
        String[] array = currentlyVersion.split("\n");//создаем массив, который разделяем на подстроки
        if (line_number >= 1 && line_number <= array.length) {//рассматривает условия, когда существует хотя бы одна строка
            // и число строк не превышает длины массива
            String str = "";//создаем пустую строку
            for (int i = 0; i < array.length; i++) {//обращаемся к циклу
                if (i == line_number - 1) {//если текущий индекс равен индексу последнего элемента, то
                    str += line + "\n";//добавляем текст в конец строки
                }
                str += array[i] + "\n";// добавляем символы новой строки
            }
            currentlyVersion = str;//принимает содержимое объекта, преобразовывает в другой объект, затем
            //сохраняет полученную строку в переменную текущей версии
        } else {
            System.out.println("Неверный номер строки!");//иначе выводим ошибку
        }
    }

    //задание 6 (Сохранение версии)
    public void saveVersion() {
        previousVersion = currentlyVersion;//заменяем предыдущую версию на текущую

    }

    //задание 7 (Просмотр сохранений)
    public void displayVersion(int version_number) {
        if (version_number == 0) {//если номер версии соответсвует 0, то
            System.out.println("Текущая версия: \n" + currentlyVersion);//выводим текущую версию
        } else if (version_number == 1) {//если номер версии соответсвует 1, то
            System.out.println("Последнее сохранение: \n" + previousVersion);//выводим предыдущую(последнюю версию)
        } else {
            System.out.println("Неверный номер версии\n");//иначе выводим ошибку
        }
    }

    //задание 8 (Удаление сохранения)
    public void deleteSave() {
        previousVersion = "";//заменяем последнюю версию на пустую строку
    }

    //задание 9 (Откат к сохранению)
    public void rollbackToSave() {
        this.currentlyVersion = this.previousVersion;//присваивает значение параметра переменной экземпляра, которая будет новой текущей версией
        this.previousVersion = "";//заменяем последнюю версию на пустую строку
        System.out.println("Откат к сохранению: \n" + currentlyVersion);//выводим новую текущую версию
    }

    //задание 10 (Сравнение версий)
    public void versionToComparison() {
        if (this.currentlyVersion.equals(this.previousVersion))//Если текст в переменной текущей версии точно совпадает
            // с текстом в переменной предыдущей версии, то выводим необходимый результат
            System.out.println("Текущая версия и последнее сохранение совпадают");
        else
            System.out.println("Текущая версия и последнее сохранение не совпадают");
    }

    //задание 11 (Общие строки между версиями)
    public static void printCommonStrings(String currentlyVersion, String previousVersion) {
        String[] currentlyLines = currentlyVersion.split("\n");//разбивает строку текущей версии на массив строк
        String[] previousLines = previousVersion.split("\n");//разбивает строку предыдущей версии на массив строк

        boolean[] flag = new boolean[previousLines.length];//Массив используется в качестве «трекера».
        // Каждый индекс в массиве соответствует строке в массиве.

        for (int i = 0; i < currentlyLines.length; i++) {//рассматриваем цикл для текущей версии
            String string = currentlyLines[i];//строка получает текущую строку и сохраняет ее в переменной
            for (int j = 0; j < previousLines.length; j++) {//рассматриваем цикл для предыдущей версии
                if (string.equals(previousLines[j])) {//сравнение элементов
                    if(!flag[i]){// проверяет, является ли логическое значение, хранящееся в индексе массива, истинным
                        System.out.println(string);//Если условие было, то в этой строке будет выведено значение,
                        // хранящееся в переменной, в консоль
                        flag[i] = true;//После вывода переменной эта строка устанавливает
                        // соответствующий элемент по индексу в массиве в значение
                    }
                    break;
                }
            }
        }
        System.out.println();
    }
    //задание 12 (Различные строки между версиями)
    public static void printVersionDiff(String currentlyVersion, String previousVersion) {
        String[] currentlyLines = currentlyVersion.split("\n");//разбивает строку текущей версии на массив строк
        String[] previousLines = previousVersion.split("\n");//разбивает строку предыдущей версии на массив строк

        boolean[] flag = new boolean[previousLines.length];//Массив используется в качестве «трекера».
        // Каждый индекс в массиве соответствует строке в массиве.

        for (int i = 0; i < currentlyLines.length; i++) {//рассматриваем цикл для текущей версии
            String newLine = currentlyLines[i];//строка получает текущую строку и сохраняет ее в переменной
            for (int j = 0; j < previousLines.length; j++) {//рассматриваем цикл для предыдущей версии
                if (newLine.equals(previousLines[j])) {//сравнение элементов
                    flag[j] = true;// указывает на то, что строка по индексу массива была найдена в массиве.
                    break;
                }
            }
        }

        for (int i = 0; i < previousLines.length; i++) {//рассматриваем цикл для предыдущей версии
            if (!flag[i]) {// проверяет, не найдена ли в массиве текущая строка, соответствующая индексу.
                //Если строка from не найдена, то флаг, соответствующий этой строке, будет ложным
                System.out.println("- " + previousLines[i]);//Если условие истинно, то
                // эта строка выводит текущую строку из массива с префиксом "-",
                // чтобы показать, что эта строка уникальна для старой версии.
            }
        }

        for (int i = 0; i < currentlyLines.length; i++) {//рассматриваем цикл для текущей версии
            String currentLine = currentlyLines[i];//строка получает текущую строку и сохраняет ее в пер
            boolean found = false;
            for (int j = 0; j < previousLines.length; j++) {//рассматриваем цикл для предыдущей версии
                if (currentLine.equals(previousLines[j])) {//сравнение элементов
                    found = true;// указывает на то, что строка по индексу массива была найдена в массиве.
                    break;
                }
            }
            if (!found) {//проверяет, не было ли найдено то, что вы искали, в предыдущих итерациях цикла
                System.out.println("+ " + currentLine);//Если условие истинно, то
                // эта строка выводит текущую строку из массива с префиксом "+",
                // чтобы показать, что эта строка уникальна для новой(текущей) версии.
            }
        }
    }

    public String getCurrentlyVersion() {
        return currentlyVersion;//возвращает значения переменной текущей версии
    }

    public String getPreviousVersion() {
        return previousVersion;//возвращает значения переменной предыдущей версии
    }
}

public class Main {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;
    public static void main(String[] args){
        // Создание экземпляра класса Git с русским стихотворением
        Git git = new Git("Название", "Автор");

        // Вывод стихотворения
        System.out.println(git);

        // Добавляем строки в стихотворение
        git.addLine("Строка 1");
        git.addLine("Строка 2");
        git.addLine("Строка 3");

        // Выводим текущую версию стихотворения
        System.out.println("Текущая версия стихотворения:");
        System.out.println(git);

        // Сохраняем текущую версию
        git.saveVersion();

        // Добавляем ещё одну строку
        git.addLine("Строка 4");

        // Выводим обновлённую версию
        System.out.println("\nОбновлённая версия стихотворения:");
        System.out.println(git);

        // Выводим сохраненную и текущую версию
        git.displayVersion(0);
        git.displayVersion(1);


        // Удаляем строку
        git.deletedLine(2); // Удаляем вторую строку

        // Выводим версию после удаления
        System.out.println("\nПосле удаления второй строки:");
        System.out.println(git);

        // Вставляем строку на 2-е место
        git.insertedLine(2, "Строка 2 новая");

        // Выводим версию после вставки
        System.out.println("\nПосле вставки строки на второе место:");
        System.out.println(git);

        // Просмотр сохранений
        //System.out.println("\nПросмотр сохранений:");
        git.displayVersion(1);


        // Сравнение версий
        System.out.println("\nСравнение текущей и предыдущей версии:");
        git.versionToComparison();

        // Различия между версиями
        System.out.println("\nРазличия между версиями:");
        Git.printVersionDiff(git.getCurrentlyVersion(), git.getPreviousVersion());

        // Общие строки между версиями
        System.out.println("\nОбщие строки между версиями:");
        Git.printCommonStrings(git.getCurrentlyVersion(), git.getPreviousVersion());

        // Откат к предыдущей версии
        git.rollbackToSave();

        // Выводим сохраненную и текущую версию
        git.displayVersion(0);
        git.displayVersion(1);

    }
}

```

### 4. Анализ правильности решения

1. Текущая версия стихотворения:

   - **Input:**
   ``` 
    «Название - Автор»
    Строка 1
    Строка 2
    Строка 3
   ``` 

   - **Output:**
   ``` 
     «Название - Автор»
    Строка 1
    Строка 2
    Строка 3
   ``` 

2. Обновлённая версия стихотворения::

   - **Input:**
   ``` 
    «Название - Автор»
    Строка 1
    Строка 2
    Строка 3
   ``` 

   - **Output:**
   ``` 
   «Название - Автор»
    Строка 1
    Строка 2
    Строка 3
    Строка 4
   ```

3. Текущая версия:

   - **Input:**
   ``` 
    «Название - Автор»
    Строка 1
    Строка 2
    Строка 3
   ``` 

   - **Output:**
   ``` 
   Строка 1
   Строка 2
   Строка 3
   Строка 4

   ``` 
4. Последнее сохранение:

    - **Input:**
   ``` 
    «Название - Автор»
    Строка 1
    Строка 2
    Строка 3
   ``` 

   - **Output:**
   ``` 
   Строка 1
   Строка 2
   Строка 3

   ```
5. После удаления второй строки:

   - **Input:**
   ``` 
    «Название - Автор»
    Строка 1
    Строка 2
    Строка 3
   ``` 

   - **Output:**
   ``` 
    «Название - Автор»
    Строка 1
    Строка 3
    Строка 4

   ```  
6. Последнее сохранение:

    - **Input:**
   ``` 
    «Название - Автор»
    Строка 1
    Строка 2
    Строка 3
   ``` 

   - **Output:**
   ``` 
   Строка 1
   Строка 2
   Строка 3

   ```  
7. Сравнение текущей и предыдущей версии:

   - **Input:**
   ``` 
    «Название - Автор»
    Строка 1
    Строка 2
    Строка 3
   ``` 

   - **Output:**
   ``` 
    Текущая версия и последнее сохранение не совпадают

   ```  
8. Различия между версиями:

   - **Input:**
   ``` 
    «Название - Автор»
    Строка 1
    Строка 2
    Строка 3
   ``` 

   - **Output:**
   ``` 
   - Строка 2
   + Строка 2 новая
   + Строка 4

      ```  
9. Общие строки между версиями:

   - **Input:**
   ``` 
    «Название - Автор»
    Строка 1
    Строка 2
    Строка 3
   ``` 

   - **Output:**
   ``` 
   Строка 1
   Строка 3

     ```  
10. Откат к сохранению:

    - **Input:**
   ``` 
    «Название - Автор»
    Строка 1
    Строка 2
    Строка 3
   ``` 

    - **Output:**
   ``` 
   Строка 1
   Строка 2
   Строка 3

     ```  
   
11. Текущая версия:

    - **Input:**
    ``` 
    «Название - Автор»
    Строка 1
    Строка 2
    Строка 3
    ``` 

    - **Output:**
    ``` 
    Строка 1
    Строка 2
    Строка 3

  ```
